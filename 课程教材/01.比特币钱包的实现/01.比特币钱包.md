# 比特币地址

在比特币中，没有用户账户，不需要也不会在任何地方存储个人数据（比如姓名，护照号码或者 SSN）。但是，我们总要有某种途径识别出你是交易输出的所有者(即比特币的拥有者)。这就是一个真实的比特币地址：1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa。这是史上第一个比特币地址，据说属于中本聪。比特币地址是完全公开的，如果你想要给某个人发送币，只需要知道他的地址就可以了。

## 钱包的实现

钱包存储的是公钥和私钥,定义钱包非常简单,使用如下结构体就能定义一个钱包了

```go
//钱包结构体包含公私钥对
type Wallet struct{
	//私钥
	PrivateKey ecdsa.PrivateKey
	//公钥(该属性可以从私钥中获取)
	PublicKey []byte 
}
```

## 实现公私钥对

实现公私钥对非常直观：ECDSA 基于椭圆曲线，所以我们需要一个椭圆曲线。接下来，使用椭圆生成一个私钥，然后再从私钥生成一个公钥。有一点需要注意：在基于椭圆曲线的算法中，公钥是曲线上的点。因此，公钥是 X，Y 坐标的组合。在比特币中，这些坐标会被连接起来，然后形成一个公钥。

```go
//构造钱包
func NewWallet() *Wallet{
	private,public := newPrivAndPub()
	return &Wallet{private,public}
}
//生成公私钥对
func newPrivAndPub()(ecdsa.PrivateKey,[]byte){
	//声明p-256曲线
	p256curve := elliptic.P256()
	//使用p256曲线生成私钥
	privKey,err := ecdsa.GenerateKey(p256curve,rand.Reader)
	if err != nil {
		log.Panic(err)
	}
	//在私钥获取公钥
	pubKey := append(privKey.PublicKey.X.Bytes(),privKey.PublicKey.Y.Bytes()...)
	return *privKey,pubKey
}
```

## 实现比特地址的步骤和图解

下图是从一个公钥获得一个地址的过程：

![get an address from a public key](https://github.com/pengjim520golang/blockchain-tutorial/blob/master/%E8%AF%BE%E7%A8%8B%E6%95%99%E6%9D%90/01.%E6%AF%94%E7%89%B9%E5%B8%81%E9%92%B1%E5%8C%85%E7%9A%84%E5%AE%9E%E7%8E%B0/images/bitcoinAddress.png)

1.使用 RIPEMD160(SHA256(PubKey)) 哈希算法，取公钥并对其哈希两次

2.给哈希加上地址生成算法版本的前缀

3.对于第二步生成的结果，使用 SHA256(SHA256(payload)) 再哈希，计算校验和。校验和是结果哈希的前四个字节。

4.将校验和附加到 version+PubKeyHash 的组合中。

5.使用 Base58 对 version+PubKeyHash+checksum 组合进行编码。

```go
//获取地址
func (wallet *Wallet) GetAddress() []byte{
	//对公钥进行Ripemd160
	pubkey160 := HashPubKey(wallet.PublicKey)
	//组合version + pubkey160
	payload := append([]byte{version},pubkey160...)
	//取其前4个字节
	checkSum := checksum(payload)
	//组合version + pubkey160 + checksum
	fullPayload := append(payload,checkSum...)
	//进行base58编码
	return Base58Encode(fullPayload)
}
//对公钥进行Ripemd160
func HashPubKey(pubkey []byte) []byte{
	pubkey256 := sha256.Sum256(pubkey)
	ripemd160Hasher := ripemd160.New()
	_,err := ripemd160Hasher.Write(pubkey256[:])
	if err != nil {
		log.Panic(err)
	}
	pubkey160 := ripemd160Hasher.Sum(nil)
	return pubkey160
}
//把version + pubkey160的结果进行两次sha256后取其前4个字节
func checksum(payload []byte) []byte{
	first256 := sha256.Sum256(payload)
	sec256 := sha256.Sum256(first256[:])
	return sec256[:addressCheckSum]
}
```

至此我们得到了比特币的地址.为了验证有效性我们需要加入一个验证地址有效性的代码

```go
//验证地址是否正确
func ValidateAddress(address []byte) bool {
	pubKeyHash := Base58Decode(address)
	srcCheckSum := pubKeyHash[len(pubKeyHash) - addressCheckSum:]
	version := pubKeyHash[0]
	pubKey160 := pubKeyHash[1:len(pubKeyHash) - addressCheckSum]
	checkSum := checksum( append([]byte{version},pubKey160...) )
	return bytes.Compare(srcCheckSum,checkSum) == 0
}
```
