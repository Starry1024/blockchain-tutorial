# 区块链的概念

区块链从严格准确的意义上说它是一个数据结构,区块记录交易信息,然后把区块信息加入到链上形成了一个数据库,区块链是一个公开的数据库,且它是分布式的,也就是说,每个使用它的人都有一个完整或部分的副本。在区块链1.0中记录的只有比特币的交易信息。

# 区块数据结构体的定义

首先从 “区块” 谈起。在区块链中，真正存储有效信息的是区块（block）。而在比特币中，真正有价值的信息就是交易（transaction）。实际上，交易信息是所有加密货币的价值所在。除此以外，区块还包含了一些技术实现的相关信息，比如版本，当前时间戳和前一个区块的哈希。

字段            | 解释
:----:          | :----
`Timestamp`     | 当前时间戳,也就是区块创建的时间
`Transactions`  | 区块存储的实际有效信息,也就是交易
`PrevBlockHash` | 前一个块的哈希,即父哈希
`Hash`          | 当前块的哈希
`Nonce`         | 随机数,主要用于工作量证明的验证和难度调整

使用结构体定义一个区块数据结构

```go
//区块数据结构
type Block struct {
	Timestamp     int64
	Transactions  []*Transaction
	PrevBlockHash []byte
	Hash          []byte
	Nonce         int
}
```

创建一个区块我们使用`NewBlock`进行创建,但我们在本小节并不会讨论如何进行工作量证明（挖矿）的操作,因此我们只是简单地解决一下区块Hash的问题,使用`setHash`构造了一个区块的Hash

```go
//创建一个区块实例
func NewBlock(transactions []*Transaction,prevBlockHash []byte) *Block{
	block := &Block{time.Now().Unix(),transactions,prevBlockHash,[]byte{},0}
	//创建区块地址
	block.setHash()
	return block
}
//设置Block的Hash(这个工作我们应该在工作量(挖矿)中实现,本小节是简单实现)
func (block *Block) setHash(){
	//组合用于哈希的区块数据
	hashData := bytes.Join([][]byte{ IntToHex(block.Timestamp),IntToHex(int64(block.Nonce)),block.HashTransactions(),block.PrevBlockHash},[]byte{})

	var hash [32]byte 
	hash = sha256.Sum256(hashData)
	//设置当前区块的哈希地址
	block.Hash = hash[:]
}
func (block *Block) HashTransactions() []byte{
    .........
}
```

`setHash`的实现非常简单就是把区块信息的字段的`[]byte`连接在一起进行sha256哈希操作,由于一个区块可以打包多笔交易所以我们添加一个`HashTransactions`的方法对交易记录进行打包

```go
//把交易打包方便在区块中存储(在比特币中应该把交易打包成为一个梅克尔树,本小节是简单实现)
func (block *Block) HashTransactions() []byte{
	var transactions [][]byte 
	for _,tx := range block.Transactions{
		transactions = append(transactions,tx.Serialize())
	}
	txHash := sha256.Sum256( bytes.Join(transactions,[]byte{}) )
	return txHash[:]
}
```

在比特币中,中本聪挖出来的区块在链中的是第一个块,通常叫做创世块(genesis block),所以我们添加一个关于创世区块的创建方法

```go
//创建创世区块
func NewGenesisBlock(coinbase *Transaction) *Block {
	return NewBlock([]*Transaction{coinbase}, []byte{})
}
```