# UTXO的概念

在比特币钱包当中，我们通常能够看到账户余额，然而在中本聪设计的比特币系统中，并没有余额这个概念。“比特币余额”是由比特币钱包应用派生出来的产物。中本聪发明了UTXO交易模型，并将其应用到比特币当中。
UTXO（Unspent Transaction Outputs）是未花费的交易输出，它是比特币交易生成及验证的一个核心概念。交易构成了一组链式结构，所有合法的比特币交易都可以追溯到前向一个或多个交易的输出，这些链条的源头都是挖矿奖励，末尾则是当前未花费的交易输出。

*UTXO跟银行里的账户余额系统不同，跟纸币的逻辑有些类似。*

假设张三要给李四转80元。如果是通过银行转账，那么服务器只需要在张三的余额里-80元，在李四的余额里+80元就可以了。

而比特币的转账跟现金更像，现金没有80元的面额，所以只能给李四100元的现金，然后李四再找回来20元现金。

*上面的例子也可以用UTXO来解释：*

张三有100元的UTXO，UTXO是不能细分的，就好像不能把现金撕开用是一个道理。所以只能先全部给到李四，然后李四再找零20元。

交易完成后产生了2个UTXO，一个是李四的80元，一个是找给张三的20元。

*UTXO具有4个优势：*

1、匿名性更好

2、更好的并行性

3、数据占用更小

4、不容易被篡改

## 定义交易结构体

```go
type Transaction struct{
	ID []byte
	Vint []TXInput
	Vout []TXOutput
}
```

一笔交易可以对应多笔输入和多笔输出,遍历`Vint`可以知道我们消费了哪些交易中的输出,遍历`Vout`可以查询交易中的可用金额总数。`ID`是表示当前交易的唯一标识。

## 定义交易中的输出

```go
type TXOutput struct {
	Value int
	PubKeyHash []byte
}
```

`Value` 表示输出的金额数量,`PubKeyHash` 是钱包地址中进行了`ripemd160`加密后公钥,如果张三给李四转账了2个比特币,`PubKeyHash` 就会锁定李四的钱包地址中`ripemd160`加密后公钥的公钥,如果李四希望查找自己一共有多少个比特币那么同样需要李四能解开`PubKeyHash`

```go
//创建输出
func NewTXOutput(value int , address string) *TXOutput{
	out := &TXOutput{value,nil}
	out.Lock([]byte(address))
	return out 
}

//锁定地址:提取地址中`ripemd160`加密后公钥
func (out *TXOutput) Lock(address []byte){
	pubKey160 := Base58Decode(address)
	pubKey160 = pubKey160[1:len(pubKey160)-4]
	out.PubKeyHash = pubKey160
}

//解锁地址:只有能解锁PubKeyHash才能确定当前输出属于谁
func (out *TXOutput) IsLockedWithKey(pubKeyHash []byte) bool {
	return bytes.Compare(out.PubKeyHash,pubKeyHash) == 0
}
```


> 注意: 可用的金额总数来自输出,每个输出必须来自一笔输入的消费,但是coinbase的交易例外（后面会讨论coinbase交易）


